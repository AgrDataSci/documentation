// scripts/build-sections-json.js
"use strict";

const fs = require("fs");
const path = require("path");

const projectRoot = path.join(__dirname, "..");
const defaultDocsRoot = path.join(projectRoot, "docs"); // typical Docusaurus docs folder

const sidebarsExport = require("../sidebars.js");
const sidebars = typeof sidebarsExport === "function" ? sidebarsExport() : sidebarsExport;

function isPlainObject(x) {
  return !!x && typeof x === "object" && !Array.isArray(x);
}

function safeRead(filePath) {
  try {
    return fs.readFileSync(filePath, "utf8");
  } catch {
    return null;
  }
}

function listFilesRecursive(dir) {
  const out = [];
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) out.push(...listFilesRecursive(full));
    else out.push(full);
  }
  return out;
}

function parseFrontMatter(text) {
  // very small YAML-ish parser for a few keys
  // expects:
  // ---
  // key: value
  // ---
  if (!text || !text.startsWith("---")) return {};
  const end = text.indexOf("\n---", 3);
  if (end === -1) return {};
  const block = text.slice(3, end).trim();
  const fm = {};
  for (const line of block.split("\n")) {
    const m = line.match(/^([A-Za-z0-9_-]+)\s*:\s*(.+)\s*$/);
    if (!m) continue;
    const k = m[1];
    let v = m[2].trim();
    // strip quotes
    v = v.replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
    fm[k] = v;
  }
  return fm;
}

function titleCaseFolder(name) {
  return name
    .replace(/[-_]+/g, " ")
    .replace(/\b\w/g, (c) => c.toUpperCase());
}

function readCategoryLabel(dir) {
  // Docusaurus supports _category_.json (common). Some repos use yml/yaml too.
  const jsonPath = path.join(dir, "_category_.json");
  const ymlPath = path.join(dir, "_category_.yml");
  const yamlPath = path.join(dir, "_category_.yaml");

  const jsonText = safeRead(jsonPath);
  if (jsonText) {
    try {
      const obj = JSON.parse(jsonText);
      if (obj && typeof obj.label === "string" && obj.label.trim()) return obj.label.trim();
    } catch {}
  }

  const yText = safeRead(ymlPath) || safeRead(yamlPath);
  if (yText) {
    // tiny YAML label extractor: label: "Something"
    const m = yText.match(/^\s*label\s*:\s*(.+)\s*$/m);
    if (m) return m[1].trim().replace(/^"(.*)"$/, "$1").replace(/^'(.*)'$/, "$1");
  }

  return null;
}

function docIdFromPath(filePath, docsRoot) {
  // Convert docs/intro/introduction.mdx -> intro/introduction
  const rel = path.relative(docsRoot, filePath).replace(/\\/g, "/");
  return rel.replace(/\.(md|mdx)$/i, "");
}

function collectDocsInDir(sectionDir, docsRoot) {
  const files = listFilesRecursive(sectionDir).filter((f) => /\.(md|mdx)$/i.test(f));
  const items = [];

  for (const f of files) {
    const txt = safeRead(f) || "";
    const fm = parseFrontMatter(txt);
    const posRaw = fm.sidebar_position;
    const pos =
      posRaw && /^[0-9]+$/.test(String(posRaw)) ? parseInt(String(posRaw), 10) : 999999;

    items.push({
      id: docIdFromPath(f, docsRoot),
      pos,
      path: f,
    });
  }

  // Sort: sidebar_position first (if present), then path
  items.sort((a, b) => (a.pos - b.pos) || a.id.localeCompare(b.id));
  return items.map((x) => x.id);
}

function buildSectionsFromAutogenerated(dirName) {
  // dirName is relative to docs root
  const docsRoot = defaultDocsRoot;
  const startDir = path.join(docsRoot, dirName);

  if (!fs.existsSync(startDir)) {
    console.warn(`Autogenerated dir does not exist: ${startDir}`);
    return {};
  }

  const sections = {};

  // section = each top-level folder under startDir
  const entries = fs.readdirSync(startDir, { withFileTypes: true });
  const topDirs = entries.filter((e) => e.isDirectory()).map((e) => e.name);

  for (const d of topDirs) {
    const sectionDir = path.join(startDir, d);
    const label = readCategoryLabel(sectionDir) || titleCaseFolder(d);
    const docs = collectDocsInDir(sectionDir, docsRoot);
    if (docs.length) sections[label] = docs;
  }

  // Also include any root-level docs (optional): files directly in startDir
  const rootFiles = fs
    .readdirSync(startDir, { withFileTypes: true })
    .filter((e) => e.isFile() && /\.(md|mdx)$/i.test(e.name))
    .map((e) => path.join(startDir, e.name));

  if (rootFiles.length) {
    const label = "General";
    const docs = rootFiles
      .map((f) => {
        const txt = safeRead(f) || "";
        const fm = parseFrontMatter(txt);
        const posRaw = fm.sidebar_position;
        const pos =
          posRaw && /^[0-9]+$/.test(String(posRaw)) ? parseInt(String(posRaw), 10) : 999999;
        return { id: docIdFromPath(f, docsRoot), pos };
      })
      .sort((a, b) => (a.pos - b.pos) || a.id.localeCompare(b.id))
      .map((x) => x.id);

    sections[label] = docs;
  }

  return sections;
}

function extractFromCategoryItems(items, outSections) {
  if (!Array.isArray(items)) return;

  for (const it of items) {
    if (!it) continue;

    if (isPlainObject(it) && it.type === "category") {
      const label = it.label || it.title || "Section";
      const docs = [];
      // collect docs under this category
      const stack = Array.isArray(it.items) ? [...it.items] : [];
      while (stack.length) {
        const x = stack.shift();
        if (!x) continue;
        if (typeof x === "string") docs.push(x);
        else if (isPlainObject(x) && x.type === "doc" && x.id) docs.push(x.id);
        else if (isPlainObject(x) && Array.isArray(x.items)) stack.push(...x.items);
      }
      if (docs.length) outSections[label] = docs;

      // recurse into nested
      if (Array.isArray(it.items)) extractFromCategoryItems(it.items, outSections);
    } else if (isPlainObject(it) && Array.isArray(it.items)) {
      extractFromCategoryItems(it.items, outSections);
    }
  }
}

function handleSidebar(val, outSections) {
  // Array sidebar
  if (Array.isArray(val)) {
    for (const it of val) {
      if (isPlainObject(it) && it.type === "autogenerated") {
        const dirName = it.dirName || ".";
        Object.assign(outSections, buildSectionsFromAutogenerated(dirName));
      }
    }
    extractFromCategoryItems(val, outSections);
    return;
  }

  // Wrapped in { items: [...] }
  if (isPlainObject(val) && Array.isArray(val.items)) {
    handleSidebar(val.items, outSections);
    return;
  }

  // Shorthand object sidebar: { "Label": [ ...doc ids... ] }
  if (isPlainObject(val)) {
    for (const [label, items] of Object.entries(val)) {
      if (Array.isArray(items)) {
        const docs = items.filter((x) => typeof x === "string");
        if (docs.length) outSections[label] = docs;
      }
    }
  }
}

// Build sections from all sidebars
const sections = {};
for (const val of Object.values(sidebars || {})) {
  handleSidebar(val, sections);
}

const outDir = path.join(projectRoot, "static", "print");
fs.mkdirSync(outDir, { recursive: true });

const outPath = path.join(outDir, "sections.json");
fs.writeFileSync(outPath, JSON.stringify(sections, null, 2), "utf8");

console.log(`Wrote ${outPath} with ${Object.keys(sections).length} sections`);
